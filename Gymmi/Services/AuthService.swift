import Foundation
import SwiftUI
import Network

enum ValidationError: LocalizedError {
    case invalidEmail
    case invalidPassword(reason: String)
    
    var errorDescription: String? {
        switch self {
        case .invalidEmail:
            return "–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç email. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π email-–∞–¥—Ä–µ—Å"
        case .invalidPassword(let reason):
            return reason
        }
    }
}

enum AuthError: Error {
    case invalidURL
    case invalidResponse
    case invalidCredentials
    case registrationFailed
    case serverError(String)
    case unauthorized
    case unknown
}

class AuthService: NSObject, ObservableObject, URLSessionDelegate {
    @Published var currentUser: GymmiUser?
    @Published var isAuthenticated = false
    @Published var error: String?
    @Published var shouldShowLogin = false
    @Published var shouldShowRegistration = false
    @Published var showSuccessView = false
    @Published var successMessage = ""
    @Published var validationErrors: [String: String] = [:]
    @Published var isLoading = false
    
    private let baseURL = "http://192.168.1.168:8000/api/v1"
    private let userDefaults = UserDefaults.standard
    private let tokenKey = "authToken"
    private var session: URLSession!
    private var networkMonitor: NWPathMonitor?
    
    override init() {
        super.init()
        setupSession()
        setupNetworkMonitoring()
        checkExistingToken()
    }
    
    private func checkExistingToken() {
        guard userDefaults.string(forKey: tokenKey) != nil else {
            print("üîë –¢–æ–∫–µ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω")
            isAuthenticated = false
            currentUser = nil
            return
        }
        
        print("üîë –ù–∞–π–¥–µ–Ω —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —Ç–æ–∫–µ–Ω")
            Task {
                do {
                    print("üîë –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ —Ç–æ–∫–µ–Ω–∞...")
                // –°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∂–∞–µ–º –ø—Ä–æ—Ñ–∏–ª—å
                    try await fetchUserProfile()
                // –ó–∞—Ç–µ–º —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
                await MainActor.run {
                    self.isAuthenticated = true
                }
                print("‚úÖ –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞")
                } catch {
                    print("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —Ç–æ–∫–µ–Ω–∞: \(error.localizedDescription)")
                    await MainActor.run {
                        self.isAuthenticated = false
                        self.currentUser = nil
                        userDefaults.removeObject(forKey: tokenKey)
                    print("‚ùå –ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –Ω–µ —É–¥–∞–ª–∞—Å—å")
                }
            }
        }
    }
    
    private func setupSession() {
        let sessionConfig = URLSessionConfiguration.default
        sessionConfig.timeoutIntervalForRequest = 60
        sessionConfig.timeoutIntervalForResource = 60
        sessionConfig.waitsForConnectivity = true
        sessionConfig.requestCachePolicy = .reloadIgnoringLocalAndRemoteCacheData
        sessionConfig.urlCache = nil
        sessionConfig.httpMaximumConnectionsPerHost = 1
        sessionConfig.shouldUseExtendedBackgroundIdleMode = true
        
        // –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–≥–æ–ª–æ–≤–∫–∏
        sessionConfig.httpAdditionalHeaders = [
            "Accept": "application/json",
            "Content-Type": "application/json",
            "Connection": "keep-alive",
            "User-Agent": "Gymmi/1.0",
            "Cache-Control": "no-cache",
            "Pragma": "no-cache"
        ]
        
        // –°–æ–∑–¥–∞–µ–º —Å–µ—Å—Å–∏—é —Å –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏
        let operationQueue = OperationQueue()
        operationQueue.maxConcurrentOperationCount = 1
        operationQueue.qualityOfService = .userInitiated
        
        session = URLSession(configuration: sessionConfig, delegate: self, delegateQueue: operationQueue)
    }
    
    // MARK: - URLSessionDelegate
    
    func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
        print("üîí –ü–æ–ª—É—á–µ–Ω –≤—ã–∑–æ–≤ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏")
        if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
            if let serverTrust = challenge.protectionSpace.serverTrust {
                let credential = URLCredential(trust: serverTrust)
                completionHandler(.useCredential, credential)
                return
            }
        }
        completionHandler(.performDefaultHandling, nil)
    }
    
    func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {
        if let error = error {
            print("‚ö†Ô∏è –û—à–∏–±–∫–∞ —Å–µ—Å—Å–∏–∏: \(error.localizedDescription)")
        }
    }
    
    private func setupNetworkMonitoring() {
        networkMonitor = NWPathMonitor()
        networkMonitor?.pathUpdateHandler = { path in
            DispatchQueue.main.async {
                print("üåê –°–µ—Ç–µ–≤–æ–π —Å—Ç–∞—Ç—É—Å: \(path.status)")
                if path.status == .satisfied {
                    print("‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω–æ")
                } else {
                    print("‚ùå –ù–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è")
                }
            }
        }
        
        let queue = DispatchQueue(label: "NetworkMonitor")
        networkMonitor?.start(queue: queue)
    }
    
    deinit {
        networkMonitor?.cancel()
        session.invalidateAndCancel()
    }
    
    func login(email: String, password: String, completion: @escaping (Bool) -> Void) {
        isLoading = true
        validationErrors.removeAll()
        
        Task {
            do {
                try await login(email: email, password: password)
                await MainActor.run {
                    isLoading = false
                    completion(true)
                }
            } catch {
                await MainActor.run {
                    isLoading = false
                    if let validationError = error as? ValidationError {
                        validationErrors["email"] = validationError.localizedDescription
                    } else if let authError = error as? AuthError {
                        switch authError {
                        case .invalidCredentials:
                            validationErrors["password"] = "–ù–µ–≤–µ—Ä–Ω—ã–π email –∏–ª–∏ –ø–∞—Ä–æ–ª—å"
                        case .serverError(let message):
                            validationErrors["general"] = message
                        default:
                            validationErrors["general"] = "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
                        }
                    }
                    completion(false)
                }
            }
        }
    }
    
    private func login(email: String, password: String) async throws {
        guard let url = URL(string: "\(baseURL)/auth/login") else {
            print("‚ö†Ô∏è –ù–µ–≤–µ—Ä–Ω—ã–π URL")
            throw AuthError.invalidURL
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue("keep-alive", forHTTPHeaderField: "Connection")
        request.setValue("Gymmi/1.0", forHTTPHeaderField: "User-Agent")
        request.timeoutInterval = 30
        
        let loginData = ["email": email, "password": password]
        request.httpBody = try JSONSerialization.data(withJSONObject: loginData)
        
        print("üì§ –û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏:")
        print("URL: \(url)")
        print("–ú–µ—Ç–æ–¥: \(request.httpMethod ?? "UNKNOWN")")
        print("–ó–∞–≥–æ–ª–æ–≤–∫–∏: \(request.allHTTPHeaderFields ?? [:])")
        print("–¢–µ–ª–æ: \(String(data: request.httpBody ?? Data(), encoding: .utf8) ?? "")")
        
        do {
            let (data, response) = try await session.data(for: request)
            
            print("üì• –ü–æ–ª—É—á–µ–Ω –æ—Ç–≤–µ—Ç:")
            guard let httpResponse = response as? HTTPURLResponse else {
                print("‚ö†Ô∏è –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –æ—Ç–≤–µ—Ç–∞")
                throw AuthError.invalidResponse
            }
            
            print("–°—Ç–∞—Ç—É—Å: \(httpResponse.statusCode)")
            print("–ó–∞–≥–æ–ª–æ–≤–∫–∏: \(httpResponse.allHeaderFields)")
            if let responseString = String(data: data, encoding: .utf8) {
                print("–¢–µ–ª–æ –æ—Ç–≤–µ—Ç–∞: \(responseString)")
            }
            
            if httpResponse.statusCode == 200 {
                let tokenResponse = try JSONDecoder().decode(TokenResponse.self, from: data)
                userDefaults.set(tokenResponse.accessToken, forKey: tokenKey)
                try await fetchUserProfile()
                await MainActor.run {
                    self.isAuthenticated = true
                }
            } else {
                let error = try JSONDecoder().decode(AuthErrorResponse.self, from: data)
                throw AuthError.serverError(error.detail)
            }
        } catch let error as URLError {
            print("‚ö†Ô∏è –û—à–∏–±–∫–∞ —Å–µ—Ç–∏: \(error.localizedDescription)")
            if error.code == .cannotConnectToHost || error.code == .networkConnectionLost {
                throw AuthError.serverError("–ù–µ —É–¥–∞–µ—Ç—Å—è –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ —Å–µ—Ä–≤–µ—Ä—É. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É.")
            }
            throw AuthError.serverError(error.localizedDescription)
        } catch {
            print("‚ö†Ô∏è –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞: \(error)")
            throw error
        }
    }
    
    func register(email: String, password: String, profile: UserProfile, completion: @escaping (Bool) -> Void) {
        isLoading = true
        validationErrors.removeAll()
        
        Task {
            do {
                try await register(email: email, password: password, profile: profile)
                await MainActor.run {
                    isLoading = false
                    completion(true)
                }
            } catch {
                await MainActor.run {
                    isLoading = false
                    if let validationError = error as? ValidationError {
                        switch validationError {
                        case .invalidEmail:
                            validationErrors["email"] = validationError.localizedDescription
                        case .invalidPassword(let reason):
                            validationErrors["password"] = reason
                        }
                    } else if let authError = error as? AuthError {
                        switch authError {
                        case .serverError(let message):
                            validationErrors["general"] = message
                        default:
                            validationErrors["general"] = "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
                        }
                    }
                    completion(false)
                }
            }
        }
    }
    
    private func register(email: String, password: String, profile: UserProfile) async throws {
        let url = URL(string: "\(baseURL)/auth/register")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        let userData: [String: Any] = [
            "email": email,
            "password": password,
            "gender": profile.gender?.rawValue as Any,
            "height": profile.height as Any,
            "weight": profile.weight as Any,
            "goal": profile.goal?.rawValue as Any,
            "target_weight": profile.targetWeight as Any,
            "diet": profile.diet?.rawValue as Any,
            "experience": profile.experience?.rawValue as Any,
            "workout_frequency": profile.workoutFrequency?.rawValue as Any
        ]
        
        print("üì§ –û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏:")
        print("URL: \(url)")
        print("–ú–µ—Ç–æ–¥: \(request.httpMethod ?? "UNKNOWN")")
        print("–¢–µ–ª–æ: \(String(data: try JSONSerialization.data(withJSONObject: userData), encoding: .utf8) ?? "")")
        
        request.httpBody = try JSONSerialization.data(withJSONObject: userData)
        
        let (data, response) = try await session.data(for: request)
        
        print("üì• –ü–æ–ª—É—á–µ–Ω –æ—Ç–≤–µ—Ç:")
        guard let httpResponse = response as? HTTPURLResponse else {
            throw AuthError.unknown
        }
        
        print("–°—Ç–∞—Ç—É—Å: \(httpResponse.statusCode)")
        print("–ó–∞–≥–æ–ª–æ–≤–∫–∏: \(httpResponse.allHeaderFields)")
        if let responseString = String(data: data, encoding: .utf8) {
            print("–¢–µ–ª–æ –æ—Ç–≤–µ—Ç–∞: \(responseString)")
        }
        
        if httpResponse.statusCode == 200 {
            let user = try JSONDecoder().decode(GymmiUser.self, from: data)
            await MainActor.run {
                self.currentUser = user
                self.isAuthenticated = true
            }
        } else {
            let error = try JSONDecoder().decode(AuthErrorResponse.self, from: data)
            throw AuthError.serverError(error.detail)
        }
    }
    
    private func checkUserExists(email: String) async throws -> Bool {
        guard let url = URL(string: "\(baseURL)/auth/check-email?email=\(email.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? email)") else {
            throw AuthError.invalidURL
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        
        let (data, response) = try await session.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse else {
            throw AuthError.invalidResponse
        }
        
        if httpResponse.statusCode == 200 {
            let result = try JSONDecoder().decode([String: Bool].self, from: data)
            return result["exists"] ?? false
        }
        
        return false
    }
    
    private func validateEmail(_ email: String) throws {
        let emailRegex = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}"
        let emailPredicate = NSPredicate(format:"SELF MATCHES %@", emailRegex)
        if !emailPredicate.evaluate(with: email) {
            throw ValidationError.invalidEmail
        }
    }
    
    private func validatePassword(_ password: String) throws {
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª–∏–Ω—ã
        if password.count < 8 {
            throw ValidationError.invalidPassword(reason: "–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞ –ø–∞—Ä–æ–ª—è - 8 —Å–∏–º–≤–æ–ª–æ–≤")
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥–æ–ø—É—Å—Ç–∏–º—ã–µ —Å–∏–º–≤–æ–ª—ã
        let allowedCharacterSet = CharacterSet(charactersIn: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_")
        if password.unicodeScalars.contains(where: { !allowedCharacterSet.contains($0) }) {
            throw ValidationError.invalidPassword(reason: "–ü–∞—Ä–æ–ª—å –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–æ–ª—å–∫–æ –∞–Ω–≥–ª–∏–π—Å–∫–∏–µ –±—É–∫–≤—ã, —Ü–∏—Ñ—Ä—ã –∏ —Å–∏–º–≤–æ–ª—ã - _")
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –Ω–∞–ª–∏—á–∏–µ –∑–∞–≥–ª–∞–≤–Ω–æ–π –±—É–∫–≤—ã
        let uppercaseLetterRegex = ".*[A-Z]+.*"
        if !NSPredicate(format: "SELF MATCHES %@", uppercaseLetterRegex).evaluate(with: password) {
            throw ValidationError.invalidPassword(reason: "–ü–∞—Ä–æ–ª—å –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–Ω—É –∑–∞–≥–ª–∞–≤–Ω—É—é –±—É–∫–≤—É")
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –Ω–∞–ª–∏—á–∏–µ —Ü–∏—Ñ—Ä—ã
        let digitRegex = ".*[0-9]+.*"
        if !NSPredicate(format: "SELF MATCHES %@", digitRegex).evaluate(with: password) {
            throw ValidationError.invalidPassword(reason: "–ü–∞—Ä–æ–ª—å –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–Ω—É —Ü–∏—Ñ—Ä—É")
        }
    }
    
    func logout() {
        userDefaults.removeObject(forKey: tokenKey)
        
        // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        currentUser = nil
        isAuthenticated = false
        
        // –û—á–∏—â–∞–µ–º –¥—Ä—É–≥–∏–µ –¥–∞–Ω–Ω—ã–µ
        resetState()
    }
    
    private func fetchUserProfile() async throws {
        guard let token = userDefaults.string(forKey: tokenKey),
              let url = URL(string: "\(baseURL)/auth/me") else {
            print("‚ö†Ô∏è –ù–µ–≤–∞–ª–∏–¥–Ω—ã–π URL –∏–ª–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç —Ç–æ–∫–µ–Ω")
            throw AuthError.invalidURL
        }
        
        var request = URLRequest(url: url)
        request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
        
        print("üì§ –ó–∞–ø—Ä–æ—Å –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:")
        print("URL: \(url)")
        print("–ú–µ—Ç–æ–¥: GET")
        print("–ó–∞–≥–æ–ª–æ–≤–∫–∏: Authorization: Bearer \(token)")
        
        do {
            let (data, response) = try await session.data(for: request)
            
            print("üì• –û—Ç–≤–µ—Ç –ø—Ä–æ—Ñ–∏–ª—è:")
            guard let httpResponse = response as? HTTPURLResponse else {
                print("‚ö†Ô∏è –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –æ—Ç–≤–µ—Ç–∞")
                throw AuthError.invalidResponse
            }
            
            print("–°—Ç–∞—Ç—É—Å: \(httpResponse.statusCode)")
            print("–ó–∞–≥–æ–ª–æ–≤–∫–∏: \(httpResponse.allHeaderFields)")
            if let responseString = String(data: data, encoding: .utf8) {
                print("–¢–µ–ª–æ –æ—Ç–≤–µ—Ç–∞: \(responseString)")
            }
            
            switch httpResponse.statusCode {
            case 200:
                do {
                    print("üì¶ –ù–∞—á–∏–Ω–∞–µ–º –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
                    print("üìÑ –ü–æ–ª—É—á–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ: \(String(data: data, encoding: .utf8) ?? "–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö")")
                    let decoder = JSONDecoder()
                    let user = try decoder.decode(GymmiUser.self, from: data)
                    print("‚úÖ –£—Å–ø–µ—à–Ω–æ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: \(user)")
                await MainActor.run {
                    self.currentUser = user
                    print("‚úÖ –ü—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω")
                    }
                } catch {
                    print("‚ö†Ô∏è –û—à–∏–±–∫–∞ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: \(error)")
                    print("‚ö†Ô∏è –î–µ—Ç–∞–ª–∏ –æ—à–∏–±–∫–∏: \(String(describing: error))")
                    if let decodingError = error as? DecodingError {
                        switch decodingError {
                        case .keyNotFound(let key, let context):
                            print("üîë –û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∫–ª—é—á: \(key.stringValue)")
                            print("üìç –ö–æ–Ω—Ç–µ–∫—Å—Ç: \(context.debugDescription)")
                        case .typeMismatch(let type, let context):
                            print("üìã –ù–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Ç–∏–ø–∞: –æ–∂–∏–¥–∞–µ—Ç—Å—è \(type)")
                            print("üìç –ö–æ–Ω—Ç–µ–∫—Å—Ç: \(context.debugDescription)")
                        case .valueNotFound(let type, let context):
                            print("‚ùå –ó–Ω–∞—á–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –¥–ª—è —Ç–∏–ø–∞: \(type)")
                            print("üìç –ö–æ–Ω—Ç–µ–∫—Å—Ç: \(context.debugDescription)")
                        default:
                            print("‚ùì –î—Ä—É–≥–∞—è –æ—à–∏–±–∫–∞ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è: \(decodingError)")
                        }
                    }
                    throw error
                }
            case 401:
                print("‚ö†Ô∏è –ù–µ–∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–π –¥–æ—Å—Ç—É–ø")
                await MainActor.run {
                    self.isAuthenticated = false
                    self.currentUser = nil
                    userDefaults.removeObject(forKey: tokenKey)
                }
                throw AuthError.unauthorized
            case 404:
                print("‚ö†Ô∏è –ü—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–µ –Ω–∞–π–¥–µ–Ω")
                await MainActor.run {
                    self.isAuthenticated = false
                    self.currentUser = nil
                    userDefaults.removeObject(forKey: tokenKey)
                }
                throw AuthError.invalidResponse
            default:
                print("‚ö†Ô∏è –ù–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–π —Å—Ç–∞—Ç—É—Å –æ—Ç–≤–µ—Ç–∞: \(httpResponse.statusCode)")
                throw AuthError.invalidResponse
            }
        } catch let error as URLError {
            print("‚ö†Ô∏è –û—à–∏–±–∫–∞ —Å–µ—Ç–∏: \(error.localizedDescription)")
            if error.code == .cannotConnectToHost || error.code == .networkConnectionLost {
                throw AuthError.serverError("–ù–µ —É–¥–∞–µ—Ç—Å—è –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ —Å–µ—Ä–≤–µ—Ä—É. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É.")
            }
            throw AuthError.serverError(error.localizedDescription)
        } catch {
            print("‚ö†Ô∏è –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞: \(error)")
            throw error
        }
    }
    
    func resetState() {
        showSuccessView = false
        successMessage = ""
        error = nil
        shouldShowLogin = false
        shouldShowRegistration = false
        validationErrors.removeAll()
    }
}

struct TokenResponse: Codable {
    let accessToken: String
    let tokenType: String
    
    enum CodingKeys: String, CodingKey {
        case accessToken = "access_token"
        case tokenType = "token_type"
    }
}

struct AuthErrorResponse: Codable {
    let detail: String
}
